___
计算机组成原理知识点梳理
===
参考资料：计算机组成原理（电子科技大学）MOOC   
2020.09.26  
符燚
***

<!-- TOC -->

- [1. 概述](#1-概述)
    - [1.1. 层次结构](#11-层次结构)
    - [1.2. 性能指标](#12-性能指标)
    - [1.3. 浮点数](#13-浮点数)
    - [1.4. 字符表示](#14-字符表示)
    - [1.5. 数据处理与存储](#15-数据处理与存储)
    - [1.6. 基本运算](#16-基本运算)
        - [1.6.1. 补码](#161-补码)
        - [1.6.2. 溢出判断](#162-溢出判断)
        - [1.6.3. 使用补码移码原码进行整数浮点数的加减乘除，搁置了~](#163-使用补码移码原码进行整数浮点数的加减乘除搁置了)
    - [1.7. 数据校验](#17-数据校验)
        - [1.7.1. 奇偶校验](#171-奇偶校验)
        - [1.7.2. 汉明校验](#172-汉明校验)
        - [1.7.3. 循环冗余校验（CRC）](#173-循环冗余校验crc)
- [2. CPU子系统](#2-cpu子系统)
    - [2.1. 寄存器组（堆）](#21-寄存器组堆)
        - [2.1.1. 通用寄存器](#211-通用寄存器)
        - [2.1.2. 暂存器](#212-暂存器)
        - [2.1.3. 指令寄存器（IR）](#213-指令寄存器ir)
        - [2.1.4. 程序计数器（PC）](#214-程序计数器pc)
        - [2.1.5. 程序状态字寄存器（PSW）](#215-程序状态字寄存器psw)
        - [2.1.6. 地址寄存器（MAR）](#216-地址寄存器mar)
        - [2.1.7. 数据缓冲寄存器（MBR）](#217-数据缓冲寄存器mbr)
        - [2.1.8. 堆栈指针（SP）](#218-堆栈指针sp)
    - [2.2. 时序部件](#22-时序部件)
    - [2.3. CPU的工作原理](#23-cpu的工作原理)
        - [2.3.1. 主要功能](#231-主要功能)
        - [2.3.2. 执行指令的流程](#232-执行指令的流程)
        - [2.3.3. 部件的控制方式](#233-部件的控制方式)
    - [2.4. 外部连接与I/O控制任务](#24-外部连接与io控制任务)
        - [2.4.1. 外部连接任务](#241-外部连接任务)
        - [2.4.2. I/O控制模式](#242-io控制模式)
    - [2.5 指令系统](#25-指令系统)
        - [2.5.1. 指令集类型](#251-指令集类型)
        - [2.5.2. 指令格式](#252-指令格式)
        - [2.5.3. 指令的寻址方式](#253-指令的寻址方式)
        - [2.5.4. 指令的功能和类型](#254-指令的功能和类型)

<!-- /TOC -->

# 1. 概述
## 1.1. 层次结构
* 输入设备、输出设备、运算器、控制器、存储器
* CPU主要由运算器、控制器等部件组成
    * 运算器。功能：算数和逻辑运算。主要由ALU（算术逻辑单元）构成。ALU以全加器为核心
    * 控制器。指令信息、状态信息、时序信息
* 存储器：存储数据和数字化后的程序
* 输入/输出设备
* 总线：数据总线、地址总线、控制总线
* 接口
* 典型架构：南北桥架构、多处理器架构（紧密耦合型多机系统、松散耦合型多机系统）、集群式架构
## 1.2. 性能指标
* 基本字长：指一次数据操作的基本位数。影响计算的精度、指令的功能
* 运算的速度
    * 外频：系统时钟频率，一般不超过300MHz。之后一般会经过频率放大
    * CPU的主频=外频*倍频系数
    * IPS：每秒执行指令数
    * CPI：执行一条指令所需的时钟周期数
    * FLOPS：每秒执行浮点运算的次数
* 数据传输率
    * 带宽：单位时间的数据传输量  
    =（位宽*工作频率）/8 B/S
* 存储器的容量
    * 主（内存）存容量：可编址的存储单元个数（取决于地址码位数）* 存储单元的位宽（表明编址单位）。
    * 外存容量：指存储器能存储的最大数据量。与地址总线码的位数无关
## 1.3. 浮点数
* IEEE754格式为例
* 32位浮点数（单精度）  
    |S|E|M|
    |:---:|:---:|:---:|
    |31|30-23|22-0|
    * S=浮点数的符号位，0表示正数，1表示负数
    * E=阶码，8位，采用移码表示（偏移2^7-1=127），阶符隐含
    * M=尾数，23位，纯小数表示，其**真值=1+M**
* 64位长浮点数（双精度）
    |S|E|M|
    |:---:|:---:|:---:|
    |63|62-52|51-0|
    * E=阶码，11位，采用移码表示（偏移2^10-1），阶符隐含
    * M=尾数，52位，纯小数表示
* 补充
    * 为了确保浮点数表示的唯一性，约定0<=M<1；
    * E位为全0且M非全0：非规范浮点数（E偏移126），则其值为=(-1)^S * M * 2^(E-126)
    * E为全0且M为全0：表示浮点数0
    * 1<=E<=254：数是规范浮点数（E偏移127），则：其值为=(-1)^S * (1+M) * 2^(E-127)
    * E为全1（255）：M为全0，则其值为=正负无穷大；M为非全0，代码无效（NaN）
    > 关于规范浮点数和非规范浮点数。  
    [计算机处理非规范浮点数效率低的实验](http://cenalulu.github.io/linux/about-denormalized-float-number/)
    * 十进制数20.59375转换为IEEE754  
    对应的二进制：10100.10011  
    移动小数点为：1.010010011 * 2^4  
    符号位S=0，阶码E=4+127=131，尾数M=010010011  
    最后得到：
        |S|E|M|
        |---:|:---:|:---|
        |0|100,0001,1|010,0100,1100,0000,0000,0000|
## 1.4. 字符表示
* ASCII码：128个字符。  
存储：7b(代码宽度)+1b(奇偶校验位)
* 汉字码：输入码（拼音输入、五笔输入）、内码（GBK、GB2312-80）、字模码（宋体、黑体）
## 1.5. 数据处理与存储
* 逻辑移位：数码位置变化（没有符号位）
* 算数移位：符号位不变，数码位置变化
* 正数补码/原码移位规则
    * 数符不变：单符号位--符号位不变，双符号位--第一符号位不变
    * 空位补0（右移时第二符号位移至尾数最高位）
* 负数补码移位
    * 数码符号位不变：单符号位--符号位不变，双符号位--第一符号位不变
    * 左移空位补0
    * 右移空位补1
* 数位扩展与压缩
    * 符号扩展：直接把符号位（0/1）填充到扩展位
    * 0-扩展：高位均为0
    * 位数压缩：弃高位、留低位
* 数据存储（按字节编址）
    * 小端模式：小地址单元存储数据的低位（即尾端）
    * 大端模式：大地址单元存储数据的低位（即尾端）
* 数据字的对齐
    * 按边界对齐（假定存储字的宽度为32位，按字节编码，字节长32位）。  
    字地址：4的倍数（低两位为0）；半字地址：2的倍数（低位为0）；字节地址：任意
    * 不按边界对齐
    ![数据字对齐](数据字的对齐.png)  
    > 按边界对齐的访存次数更低（访存次数指访问字地址的次数 如上图分别是1+1+2+1=5次和1+1+3+1=6次）
## 1.6. 基本运算
### 1.6.1. 补码
* X的补码=X+2^n。过程中以2^n为模，即除以2^n后取余
* (-Y)补也可表示为((Y补)变补)。变补：不论（Y补）是正还是负，连其符号位一起变反，末位加 1。(-Y)补也称Y补的机器负数
* (X+Y)补=X补+Y补
* (X-Y)补=X补+(-Y)补
* 补码和移码的关系：符号位相反、数值位相同
### 1.6.2. 溢出判断
* 结果的符号记为Sf，符号位的进位记为Cf，尾数最高位的进位记为C，加数A的符号记为Sa，加数B的符号记为Sb。*以!(Sf)表示Sf的非*
1. 溢出逻辑=(!Sa)(!Sb)Sf+SaSb(!Sf)
2. 溢出逻辑=Cf与C的异或
3. 溢出逻辑=Sf1与Sf2的异或（双符号位的情况：Sf1与Sf2表示结果中符号位的高位和低位）
* 溢出逻辑为1表示有溢出
### 1.6.3. 使用补码移码原码进行整数浮点数的加减乘除，搁置了~
## 1.7. 数据校验
### 1.7.1. 奇偶校验
* 增加一位校验位，使得1的个数是奇数或者偶数个
* 不能发现偶数位错误
* 无法定位错误
### 1.7.2. 汉明校验
* 是一种多重分组奇偶校验
* 能够检验是否出错，也能定位出错位
### 1.7.3. 循环冗余校验（CRC）
* 用待校验数据除以某个约定代码（生成多项式），能除尽则表明数据正确，否则通过循环移位校正出错位
* 生成多项式的最高位和最低位必须是1
* CRC码中任何一位出错，根据生成多项式得到的余数不全为0
* 不同位数发生错误，生成多项式得到的余数互不相同
* 余数继续做模2运算，应能使余数循环出现
* 生成多项式的例子：
    * CRC-4：10,011 ITU G.704
    * CRC-8：100,110,001 CCITT
    * CRC-16：10,001,000,000,100,001 CCITT
    * CRC-32：32、26、23、22、16、12、11、10、8、7、5、4、2、1、0位为1 IEEE
* CRC利用余数检错（仅一位出错时）
    * 余数为全0时，数据无措
    * 余数非全0时，数据有错，且余数与出错位存在一一对应关系。余数001对应最低位出错位
    * 相邻两个非0余数，对应的出错位也相邻
    * 任何一个非0余数，循环执行余数低位补0并重新计算余数，余数会循环出现，对应的出错位也在随之循环左移，循环周期T=2^n-1，n为余数的位数
* CRC纠错（仅一位出错时）
    * 始终将余数001作为出错位的定位依据
    * 每一步循环中，余数补0产生新的余数，数据需循环左移1位，以保持余数和出错位的对应关系。
    * 当余数001第一次出现时，将当前数据的最低位变反
    * 初始余数再次出现时，结束循环，刚好是T=2^n-1步
    * 无须定位出错位，仅通过一次码位变反和T次循环操作，即可纠正出错位
    * 一般不会试图纠正多位出错，代价太大
# 2. CPU子系统
* 主要部件有：时序系统、控制部件、缓存部件、寄存器（堆）、运算部件。通过数据/控制通路互连，实现信息交互
## 2.1. 寄存器组（堆）
* 存储各种用途的数据信息
* 一般用小容量的多端口存储器来构成寄存器组，其中一个存储单元为一个寄存器
### 2.1.1. 通用寄存器
* 多个
* 通用寄存器有全局唯一地址，可通过地址码访问，可在机器指令中直接使用
* 提供操作数、地址码、存放运算结果等
### 2.1.2. 暂存器
* 多个
* 内部专用，无需分配地址码，不能在机器指令中使用
* 用来暂存产生的临时数据，以备在后续操作中使用
### 2.1.3. 指令寄存器（IR）
* 只有一个
* 用于存放指令代码，从存储器（或者指令缓存）中读取到指令以后，就直接存入到指令寄存器
### 2.1.4. 程序计数器（PC）
* 仅一个
* 用来指明指令在存储器中存放位置，即存储单元的地址码
* 取指令结束后，PC保存的地址码自动修改，以指向下一条指令的存储单元，修改量取决于指令字长和存储器的编址单元
### 2.1.5. 程序状态字寄存器（PSW）
* 仅一个
* 记录现行程序的运行状态和程序的工作模式
* PSW——特征位
    * 也叫标志位，反映CPU的当前状态
    * 指令执行时，根据情况自动设置这些特征位，作为后续操作的判断依据，通常有5类
        |进位C|溢出V|零值Z|负值N|奇偶P|
        |:--:|:--:|:--:|:--:|:--:|
    * 自动设置这些标志位，具备该特征，就设置该标志位=1
* PSW——编程设定位
    * PSW中某些位或字段可通过程序来设定，以决定程序的调试、对中断的响应、程序的运行模式等
        |跟踪位T|允许中断I|程序优先级P|运行模式|
        |:--:|:--:|:--:|:--:|
    * 通过外部程序设定
### 2.1.6. 地址寄存器（MAR）
* 只有一个
* 读写存储器时，先要定位存储单元，因此设置MAR来存放目标单元的地址码。先将有效地址送入MAR，再启动后续的读写操作
### 2.1.7. 数据缓冲寄存器（MBR）
* 只有一个
* 过渡性的存放CPU和主存之间交换的数据
* 无论是从主存读取的数据，还是写入到主存的数据，都要经过MBR
### 2.1.8. 堆栈指针（SP）
* 仅一个
* 固定存放堆栈（存储器）的栈顶单元的地址码。根据这个地址码，去读写堆栈
## 2.2. 时序部件
* 低频震荡器->倍频逻辑->CPU时钟周期信号->机器周期信号->指令周期信号
* 指令周期包含若干（>=2）个机器周期。至少需要取指令和执行的阶段
* 机器周期至少包括1个时钟周期。如：取指令
## 2.3. CPU的工作原理
### 2.3.1. 主要功能
* 处理指令--控制指令的执行顺序
* 执行操作--产生控制信号控制部件工作
* 控制时间--控制各步操作的时序
* 数据运算--算数和逻辑运算
### 2.3.2. 执行指令的流程
* 读取指令--从存储器中读取
* 指令译码--通过控制器进行，产生控制信号
* 指令执行--寻址、取数、运算
* 后续工作--保存结果、响应外部请求等
### 2.3.3. 部件的控制方式
* 同步控制方式
    * 每步操作都向统一的外部时序信号对齐。都是靠外部时钟信号的驱动来实现协同
    * 各步操作之间无交互
* 异步控制方式
    * 各步操作都不需向统一的外部时序信号对齐
    * 各步操作之间通过交互应答来实现协同
## 2.4. 外部连接与I/O控制任务
### 2.4.1. 外部连接任务
* 单处理机系统：CPU通过前端总线与北桥芯片组连接
* 多处理机系统：高性能CPU中集中了主存、视频和PCI-E接口，CPU之间通过QPI、芯片组之间通过DMI总线相连
### 2.4.2. I/O控制模式
* 主机与外设之间进行数据输入/输出操作时，在不同的I/O控制模式下，CPU承担的任务各不相同
1. 程序传送模式：CPU直接执行I/O指令
2. 中断模式：CPU执行中断服务程序
3. DMA模式：CPU管理DMA控制器、善后处理（加密、解密、压缩等）
4. IOP和PPU模式：CPU组织I/O程序，管理IOP与PPU，以及善后处理
## 2.5 指令系统
* 指令（instruction）：计算机执行某类操作的信息的集合，是CPU工作的主要依据
* 指令集（instruction set）：处理器能执行的全体指令的集合（CISC、RISC）
    * 决定了计算机的硬件功能
    * 计算机中软硬件的分界面
* 指令字：用来表示指令的一组二进制代码
* 指令字长：指令中包含的二进制代码位数
* 机器字长：计算机能够直接处理的二进制数据的位数（=寄存器的宽度）
### 2.5.1. 指令集类型
* CISC
    * 复杂指令集计算（Complex Instruction Set Computing）
    * 早期的计算机部件昂贵、速度慢，为了扩展硬件功能，不得不将更多更复杂的指令加入到指令系统中，以提高计算机的处理能力
    * 特点
        * 指令数量多
        * 指令长度可以不固定，指令格式和寻址方式多样
        * 很多指令会涉及存储器的读写操作，指令周期长
        * 一般在通用处理器中使用
* RISC
    * 精简指令集计算（Reduced Instruction Set Computing）
    * 直接通过硬件方式，而不是扩充指令来实现复杂功能，指令规模逐渐缩小，指令进一步简化
    * 特点
        * 指令数量少
        * 指令长度固定，指令格式和寻址方式种类也少
        * 一般只有少量指令（如取数/存数）才会读写存储器，其余指令只涉及CPU内部寄存器，指令周期短
        * 一般只是在高端服务器CPU中使用
* CISC的不足
    * 2-8规律：CISC中的不同指令使用频率悬殊  
    简单指令（约占20%）约占80%的使用频率，复杂指令（约占80%）只占大约20%的使用频率
    * 不利于VLSI（超大规模集成电路）工艺：为实现大量的复杂指令，控制逻辑极不规整，给VLSI工艺造成很大困难
    * 主存技术的发展：一般通过保存在控制存储器中的微程序来实现复杂指令，70年代后期使用DRAM（动态随机存取存储器）做主存，使主存和控制存储器的速度相当，因此很多复杂指令不必再用微程序来实现，可以用简单指令构成的子程序实现等效功能
### 2.5.2. 指令格式
* 指令的基本格式
    |操作码|地址码A/操作数D|
    |:-:|:-:|
    |1个|1个或几个|
* 指令字长
    * 定长指令格式：规整、便于控制
    * 变长指令格式：合理利用存储空间、提高取指令的效率，如超长指令集
* 操作码结构
    * 定长操作码：各指令的位置、位数固定
    * 扩展操作码：该指令的位置、位数不固定，根据需要变化（设置扩展标志）
    * 复合型操作码：操作码分为几段，每段表示一种二级操作
* 地址结构
    * 指令中提供的地址：地址偏移量/立即数或者寄存器编号
    * 指令中提供地址的方式
        * 显式地址方式：指令中明确指明地址码（直接/间接给出）
        * 隐式地址方式：地址码隐含约定，不在指令中出现
        * 使用隐式地址，可以减少指令中的地址数量，从而简化地址结构
* 常见的地址结构类型
    * 四地址结构指令
        |操作码|操作数地址A1|操作数地址A2|结果地址A3|下一条指令地址A4|
        |:-:|:-:|:-:|:-:|:-:|
        * 功能：A1与A2进行操作码指定的操作后，结果放入A3，并用PC寄存器指示下条指令的地址A4
        * 在RISC中很少使用
        * 通常会使用隐含的方式使用下一条指令的地址码
    * 三地址结构指令
        |操作码|操作数地址A1|操作数地址A2|结果地址A3|
        |:-:|:-:|:-:|:-:|
        * 功能：A1与A2进行操作码指定的操作后，结果放入A3，PC寄存器自动修改为指向下一条指令
        * 如：`ADD rd,rs,rt`
    * 二地址结构指令
        |操作码|目的地址A1|源地址A2|
        |:-:|:-:|:-:|
        * 功能：A1与A2进行操作码指定的操作，结果放入A1，PC寄存器自动修改为指向下一条指令
        * 如`ADD R1,R0`
    * 一地址结构指令
        |操作码|源/目的地址A1|
        |:-:|:-:|
        * 双操作数：将A1中的地址和隐含的PC中保存的地址码拼接，结果放入PC。其中的PC地址是通过操作码隐含约定的
        * 单操作数：A1进行操作码指定的操作，结果放入A1。PC寄存器自动修改为指向下一条指令
    * 零地址结构指令
        |操作码|
        |:-:|
        1. 用于处理机的特殊控制（如HLT、NOP）
        2. 针对隐含约定的寄存器。如返回指令：`RST`，隐含操作是将堆栈栈顶单元中的地址送入PC，同时修改堆栈指针寄存器中保存的地址码,使堆栈指针寄存器中的地址码始终指向堆栈的栈顶单元
* 操作数类型
    * 地址码数据：寄存器编号或者存储器地址，无符号整数
    * 数值型数据：定点数、浮点数等，一般用补码表示
    * 字符型数据：通常表示为ASCII码/汉字内码表示
    * 逻辑型数据：常规二进制数据，不具备数值含义
* MIPS32架构的指令格式
    * RISC
    * 指令字长：32位
    * 寄存器数量：32个
    ![MIPS32架构的指令格式](MIPS32架构的指令格式.png)
    > R型(register format)：寄存器型  
    > I型(immediate format)：立即数型  
    > J型(jump format)：跳转型  
    > op：操作码
### 2.5.3. 指令的寻址方式
* 指形成操作数地址或寻找操作数的方式
* 立即寻址：指令中直接包含了操作数
    * 定长格式：`操作码+……+立即数`。数在指令中，其长度固定，位数少
    * 变长格式：`基本操作`  +  `立即数`。数在基本指令后，其长度可与指令等长
    * 常通过立即数来提供偏移量、常数、设置初值等
* 直接寻址：指令中直接给出操作数的地址码
    * 给出存储单元地址（数据在主存中）、或者给出寄存器编号（数据在寄存器中）
    * 主存直接寻址（绝对地址）
        * 定长格式：`操作码+……+有效地址`。有效地址位置有限，限制访存范围
        * 变长格式：`基本操作`  +  `有效地址`。有效地址的位数可等于指令字长，覆盖整个存储空间
    * 寄存器直接寻址
* 间接寻址：指令给出操作数的间接地址
    * 给出存储单元地址、或者给出寄存器编号，访问它们，得到其中地址码，根据地址码访问存储器，得到操作数。数据均在存储器中
    * 一般在CISC中使用，RISC中一般不用
    * 主存间接寻址：`操作码+间接地址`，间接地址是主存单元地址，主存单元中的是操作码的主存单元地址
    * 寄存器间接寻址：`操作码+寄存器号`。修改寄存器的内容比主存快，所以应用频率更高。寄存器可近似指针，可以指向不同的存储单元
    * 堆栈间接寻址：`操作码+堆栈指针SP`。
* 变址、基址寻址及其变化
    * 变址寻址：指令给出一个寄存器号和一个地址量，寄存器内容（偏移地址）和地址量之和为有效地址
    * 基址寻址：指令给出一个寄存器号和一个地址量，寄存器内容（基址地址）和地址量之和为有效地址（二维数组的读写）
    * 变址和基址的区别：有效地址=寄存器内容+指令中的立即数。变址寻址中，指令提供基准量，寄存器提供偏移量；基址寻址中，指令提供偏移量，寄存器提供基准量
    * 基址+变址：指令给出两个寄存器号和一个地址量，寄存器内容与地址量之和为有效地址（处理三维数组）
* PC相对寻址：指令给出偏移量，PC当前值与偏移量相加得到有效地址
    * PC指程序计数器，是隐含指定的
    * 可看作是一种特殊的基址寻址方式
    * 有效地址相对于PC浮动，编程方便
* 页面寻址（伪直接寻址）：指令给出位移量，PC的高位部分与位移量**拼接**，形成有效地址。
    * 给出的位移量即为低位地址
    * 寻址速度快，适用于组织程序模块，能够有效利用存储空间
* 指令中的存储方式的约定方式
    * 操作码可隐含说明不同寻址方式
    * 指令中可设置寻址方式字段。
### 2.5.4. 指令的功能和类型
* 设计指令时需要考虑
    * 按指令格式：单、双操作数指令等
    * 按操作数寻址方式：RR型（寄存器-寄存器）、RX型（寄存器-变址寄存器）……
    * 按指令功能：传送、访存、I/O、算术逻辑运算、程序控制、处理机控制等指令
* 数据传送类指令
    * 将源地址对应的存储单元中的数据放入目的地址对应的存储单元
    * 主要包括：取数指令、存数指令、数据传送（单字、成组）、数据交换和堆栈操作等
    * 主要用来实现寄存器之间、存储单元之间以及寄存器-存储器单元的数据传送
    * 设计传送指令需要考虑：规定传送范围、指明传送单位、设置寻址方式
* 输入输出(I/O)指令
    * 主机和外部设备之间信息的交互      
    * I/O指令对设备的适应性。如何使I/O指令实现对各种具体设备的控制？
        * I/O指令中留有扩展余地：指令中某些字段事先不定义，需要时再约定其含义，用于各种外设种类、数量不多的场合
        * 把设备抽象化、透明化处理：接口中设置控制/状态/数据寄存器
    * 主机对外设的寻址方式。寻找I/O接口中寄存器的方式，该类寄存器的编号，也称I/O端口的地址。如何为I/O端口分配地址？
        * 单独编制。I/O单元的地址系统和主存单元的地址系统是独立的
        * 统一编制。I/O单元的地址码和主存单元的地址码是不同的
    * I/O指令的设计思路
        * 设计专用的I/O指令（显式I/O指令）：针对端口自行单独编址，用I/O指令访问I/O端口。指令中说明I/O类型，并给出端口地址
        * 用传送指令替代I/O指令（隐式I/O指令）：针对端口和主存统一编址，用访存指令访问I/O端口，故不必再设计专用的I/O指令
        * 设计IOP进行I/O操作控制。IOP指专用I/O的控制器，CPU不亲自进行I/O控制。设计两级的I/O指令；1、CPU控制IOP（如启动、停止等）；2、IOP控制具体的I/O操作（如保存等）
* 算术/逻辑运算指令
    * 算数运算指令：设计时需要考虑操作数类型、符号、进制等，运算结束后设置CPU相应状态标志寄存器
    * 逻辑运算指令：常用来对码位的设置和条件判断等操作
* 程序控制类指令
    * 主要用于控制指令的执行流程
    * 转移指令：无条件转移（操作码+转移地址）、条件转移（操作码+转移地址+转移条件）、循环（转移条件为循环计数值）等
    * 转子指令和返回指令
        * 转子：即调用，操作码+子程序入口
        * 返回：操作码+返回地址（堆栈的顶单元中）
        * 同一条返回指令应能提供多个不同的返回地址（条件返回），一般用堆栈存放返回地址
    * 软中断指令：早期用于程序的调制，现在常常用于系统功能调用。常用INT n的指令形式出现在程序中（n表示不同的功能号）。
* 控制处理机的专用指令：如CPU状态字标志位的清除、修改、空操作指令NOP、暂停HLT、等待WAIT，总线锁定LOCK
* 面向操作系统的指令：提供给操作系统专用，如访问系统寄存器、检查保护属性、存储管理等