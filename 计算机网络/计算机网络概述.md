___
计算机网络知识点梳理
===
参考资料：计算机网络（哈尔滨工业大学：李全龙、聂兰顺）MOOC   
2020.04.17  
符燚
***

<!-- TOC -->

- [1. 基础](#1-基础)
    - [1.1. 计算机网络结构](#11-计算机网络结构)
    - [1.2. 应用模型：](#12-应用模型)
        - [1.2.1. 客户/服务器应用模型](#121-客户服务器应用模型)
        - [1.2.2. 对等应用模型（P2P）](#122-对等应用模型p2p)
    - [1.3. 交换设备与交换网络](#13-交换设备与交换网络)
    - [1.4. 多路复用技术](#14-多路复用技术)
    - [1.5. 性能](#15-性能)
        - [1.5.1. 速率](#151-速率)
        - [1.5.2. 带宽](#152-带宽)
        - [1.5.3. 时延](#153-时延)
        - [1.5.4. 时延带宽积](#154-时延带宽积)
        - [1.5.5. 丢包](#155-丢包)
        - [1.5.6. 吞吐量(率)](#156-吞吐量率)
    - [1.6. 计算机网络的体系结构](#16-计算机网络的体系结构)
    - [1.7. 协议](#17-协议)
    - [1.8. OSI-RM](#18-osi-rm)
        - [1.8.1. 物理层](#181-物理层)
        - [1.8.2. 数据链路层](#182-数据链路层)
        - [1.8.3. 网络层](#183-网络层)
        - [1.8.4. 传输层](#184-传输层)
        - [1.8.5. 会话层](#185-会话层)
        - [1.8.6. 表示层](#186-表示层)
        - [1.8.7. 应用层](#187-应用层)
    - [1.9. TCP/IP参考模型](#19-tcpip参考模型)
        - [1.10. 五层参考模型](#110-五层参考模型)
- [2.应用层](#2应用层)
    - [2.1. 网络应用的体系结构](#21-网络应用的体系结构)
    - [2.2. 网络应用的通信](#22-网络应用的通信)
    - [2.3. Web应用](#23-web应用)
    - [2.4. Email应用](#24-email应用)
    - [2.5. DNS应用](#25-dns应用)
    - [2.6. P2P应用](#26-p2p应用)
    - [2.7. Socket编程](#27-socket编程)
        - [2.7.1. 套接字API中定义的地址结构](#271-套接字api中定义的地址结构)
        - [2.7.2. Socket API函数](#272-socket-api函数)
- [3.传输层](#3传输层)
    - [3.1. 多路复用/分用](#31-多路复用分用)
        - [3.1.1. 分用](#311-分用)
        - [3.1.2. 复用](#312-复用)
    - [3.2. UDP协议](#32-udp协议)
    - [3.3. 可靠数据传输](#33-可靠数据传输)

<!-- /TOC -->


# 1. 基础

## 1.1. 计算机网络结构
网络边缘(主机、网络应用)、接入网络(有线或无线通信链路)、网络核心(路由器网络。关键功能：路由加转发)  
## 1.2. 应用模型：
### 1.2.1. 客户/服务器应用模型
客户发送请求，接收服务器响应。主动发起通信的为客户端。所有的服务都在客户和服务器之间进行。
### 1.2.2. 对等应用模型（P2P）
可以没有专用服务器，没有客户/服务器的区分。通信在对等的实体之间直接进行
## 1.3. 交换设备与交换网络   
电路交换、报文交换、分组交换。  
* 报文交换：多个路由节点间串行，相对较慢；路由器缓存需求大
* 分组交换：多个路由节点间并行，相对较快；路由器缓存需求小；统计多路复用，相比于电路交换，可以允许更多用户同时使用网络，适用于突发数据传输网络；可能产生拥塞现象（分组延迟或丢失）
* 电路交换：资源占用
## 1.4. 多路复用技术
频分、时分、波分、码分、统计多路复用
## 1.5. 性能
### 1.5.1. 速率
单位时间（秒）传输信息（比特）量  
b/s(bps)、kb/s、Mb/s……  
这里的k=10^3、M=10^6……
### 1.5.2. 带宽
网络中的带宽通常指数字信道所能传送的“最高数据率”，单位为b/s（bps）
### 1.5.3. 时延
* 节点处理延迟：差错检测、确定输出链路
* 排队延迟：等待输出链路可用，取决于路由器的拥塞程度
* 传输延迟：分组长度、链路带宽
* 传播延迟；物理链路长度、信号传播速度
### 1.5.4. 时延带宽积
时延带宽积=**传播**延迟*带宽  
意义：这个链路上能容纳多少个比特  
又称为以比特为单位的链路长度  
### 1.5.5. 丢包
路由器的可用缓存满了，到达的分组被丢弃（丢包）。可由前序节点或源重发（或不重发）  
丢包率=丢包数/已发分组总数
### 1.5.6. 吞吐量(率)
发送端与接收端之间传送数据速率（b/s）  
* 即时吞吐量：给定时刻的速率
* 平均吞吐量：一段时间的平均速率  
端到端的吞吐量取决于链路中最小的带宽
## 1.6. 计算机网络的体系结构  
计算机网络的体系结构是从功能上描述计算机网络结构，而不是从物理上。  
计算机网络体系结构是一个分层结构。 
## 1.7. 协议  
* 协议的的三要素：语法、语义、时序  
* 协议是控制两个对等实体进行通信的规则的集合，协议是“水平的”
## 1.8. OSI-RM
目的是支持异构网络系统的互联互通，理论成功

![OSI参考模型图](OSI模型.jpg)
提供者，请求它完成某项工作，用于高层向低层请求某种业务。  
> + 指示(Indication): 用于提供业务的层向高层报告一个与特定业务相关的动作，由服务提供者发往服务用户，指示发生了某些事件  
> + 响应(Response): 用于应答，表示来自高层的指示原语已收到，由服务用户发往服务提供者，对前面发生的指示的响应  
> + 确认(Confirmation): 用于提供业务的层证实某个动作已经完成，由服务提供者发往服务用户，对前面发生的请求的证实 
* 控制信息：每层增加控制信息  
在头部(数据链路层头尾都有)增加构造协议数据单元(PDU)
> + 地址  
> + 差错检测编码  
> + 协议控制：优先级、服务质量、安全控制等  
### 1.8.1. 物理层
* 接口特性：机械特性、电气特性、功能特性、规程特性  
* 比特编码
* 数据率（传输速率）
* 比特同步：时钟同步
* 传输模式：单工、半双工、双工
### 1.8.2. 数据链路层
负责结点-结点数据传输，以帧为单位  
* **物理**寻址(不能跨越网络)
* 差错控制
* 流量控制：匹配发送方与接收方的发送速度与接受速度，避免淹没接收端  
* 接入(访问)控制：决定哪个设备具有链路(物理介质)的控制使用权  
### 1.8.3. 网络层
负责源主机到目的主机数据分组交付
* **逻辑**寻址：全局唯一逻辑地址，确保数据分组被送到目的主机，如IP地址
* 路由：路由器互联网络；路径选择
* 分组转发
### 1.8.4. 传输层
负责源-目的(端-端)(**进程间**)完整报文传输  
* 报文的分段与重组
* SAP寻址：确保将完整报文提交给正确进程，如端口号
* 端到端的连接控制：端到端连接的建立、维护和清除。这是一种逻辑链接
* 端到端的流量控制：匹配数据的发送、接受速度问题  
* 差错控制：从端系统的角度引入差错控制、纠正机制等
### 1.8.5. 会话层
* 对话控制：建立、维护、拆除
* 同步：在数据流中插入“同步点”
* 最“薄”的一层
### 1.8.6. 表示层
处理两个系统间交换信息的语法和语义问题
* 数据表示转化：转换为主机独立的编码
* 加密/解密
* 压缩/解压缩
### 1.8.7. 应用层
支持用户通过用户代理(如浏览器)或网络接口使用网络(或服务)  
典型的应用层服务：文件传输(FTP)、电子邮件(SMTP)、Web(HTTP)  
## 1.9. TCP/IP参考模型
![TCP/IP参考模型](TCP_IP参考模型.jpg)  
* IP可为各式各样的应用程序提供服务(Everything over IP)
* IP可应用到各式各样的网络上(IP over Everything)
* 网络接口层要求：只要能封装IP分组，将IP分组从一点传输到另一点就可，无其他限制  

### 1.10. 五层参考模型
* 物理层：比特传输
* 数据链路层：相邻网络元素(主机、交换机、路由器等)的数据传输  
以太网、802.11(WiFi)、PPP
* 网络层：源主机到目的主机的数据分组路由与转发  
IP协议、路由协议等
* 传输层：进程-进程的数据传输  
TCP、UDP
* 应用层：支持各种网络应用  
FTP、SMTP、HTTP  
>综合OSI与TCP/IP的优点：结构清晰与易用性  

# 2.应用层

## 2.1. 网络应用的体系结构
**1. 客户机/服务器结构（Client-Server,C/S）**
> 服务器  
> * 7*24小时提供服务  
> * 永久性访问地址/域名
> * 利用大量服务器实现可扩展性

> 客户机
> * 与服务器通信，使用服务区提供的服务
> * 间歇性接入网络
> * 可能使用动态的IP地址
> * 不会与其他客户机直接通信  

**2. 点对点结构（Peer-to-Peer,P2P）**
> * 没有永远在线的服务器  
> * 任意端系统/节点之间可以直接通讯  
> * 节点间歇性接入网络  
> * 节点可能改变IP地址  
* 优点：高度可伸缩
* 缺点：难于管理

**3. 混合结构（Hybrid）**
## 2.2. 网络应用的通信
* 进程间通信利用socket(套接字)发送/接受消息实现。传输基础设施向进程提供API  

* 寻址进程：
> * IP地址：寻址主机
> * 端口号/Port number：为主机上每个需要通信的进程分配一个端口号
> * 进程的标识符：IP地址+端口号  
* 网络应用遵循应用层协议
> * 公开协议：以允许互操作；协议由RFC定义，由IETF维护。如HTTP等
> * 私有协议：多数P2P文件共享应用
* 应用层协议的内容
> * 消息的类型(type)：请求消息、响应消息
> * 消息的语法格式：消息中有哪些字段、每个字段如何描述
> * 字段的语义：字段中信息的含义
> * 规则：进程何时发送/响应消息
* 网络应用对传输服务的需求
> * 数据丢失/可靠性
> * 时间/延迟
> * 带宽
* TCP
> * 面向连接：客户机/服务器进程间需要建立连接  
> * 可靠的传输
> * 流量控制：发送方不会发送速度过快，超过接收方的处理能力
> * 拥塞控制：当网络负载过重时能够限制发送方的发送速度
> * 不提供时间/延迟保障
> * 不提供最小带宽保障
* UDP
> * 无连接
> * 不可靠的数据传输
> * 不提供可靠性保障、流量控制、拥塞控制、延迟保障、带宽保障

## 2.3. Web应用
对象的寻址：URL(统一资源定位器)  
'Scheme://host:port/path'(协议+主机地址+端口号+路径)

**HTTP(超文本传输协议)**
* C/S架构
* 使用TCP传输服务
* 无状态：服务器不维护任何有关客户端过去所发送请求的信息
* HTTP连接的两种类型
    * 非持久性连接  
    每个TCP连接最多允许传输一个对象，HTTP 1.0版本使用
    * 持久性连接  
    每个TCP允许传输多个对象，HTTP 1.1版本默认使用  
       * *无流水的持久性连接*：客户端只有在收到前一个响应后才发送新的请求
       * *带有流水机制的持久性连接(HTTP 1.1版本默认选项)*：客户端只要遇到一个引用对象就尽快发出请求
* HTTP协议的两类消息
    * 请求消息  
      * ASCII：人直接可读的
        > request line: method URL version  
        >
        > header lines：`//头部行`
        >>Host   
        >>User-agent  
        >>Connection  
        >>Accept-language  
        >>Entity Body  

        >例如：  
        >GET /somedir/page.html HTTP/1.1  
        >Host: www.someschool.edu  
        >User-agent: Mozilla/4.0  
        >Connection: close `//连接是否断开 `  
        >Accept-language: fr `//需要的语言`   

      * 上传输入的方法  
        > **GET**：获取网页。如果需要上传少量消息，可以放在URL字段里  
        > **POST**：把网页需要填写的数据放在消息体Entity Body里。  
        > **HEAD**：请Server不要将所请求的消息放在响应消息里  
        > **PUT**：将消息体中的文件上传到URL字段所指定的路径  
        > **DELETE**：删除URL字段所指定的文件  

    * 响应消息  
      * ASCII：人直接可读的
        >例如：  
        > status line : HTTP/1.1 200 OK  
        `//状态行//200 Ok是返回状态响应码`  
        >
        > header lines
        >> Connection： close   
        >> Date： Thu， 06 Aug 1998 12:00:15 GMT   
        >>`//生成时间`   
        >> Server： Apache/1.3.0 (Unix)  
        >> Last-Modified： Mon，22 Jun 1998 …...  
        >>`//修改时间`  
        >> Content-Length： 6821  
        >> Content-Type： text/html  
        > 
        > data data data data data ...  
    
      * 响应状态码  
        > 200 OK  
        > 301 Moved Permanently  
        > 400 Bad Request  
        > 404 Not Found  
        > 505 HTTP Version Not Supported  
* Cookie技术
    * 某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）
    * 组件  
        * HTTP响应消息的cookie头部行
        * HTTP请求消息的cookie头部行
        * 保存在客户端主机上的cookie文件，有浏览器管理
        * Web服务器端的后台数据库

**Web缓存/代理服务器技术**
* 在不访问服务器的前提下满足客户端的HTTP请求
* 性能优化的技术  
    * 缩短客户请求的响应时间
    * 减少机构/组织的流量
    * 在大范围内（Internet）实现有效的内容分发
* HTTP中的条件性GET方法(解决缓存的Web对象是否与远端服务器一致的问题)
    >目标：如果缓存有最新的版本，则不需要发送请求对象  
    >缓存：在HTTP请求消息中声明所持有版本的日期  
    > `If-modified-since:<data>`  
    >服务器：如果缓存的版本是最新的，则响应消息中不包含对象  
    > `HTTP/1.0 304 Not Modified`

## 2.4. Email应用
* SMTP协议：Email消息的传输/交换协议
    * 使用TCP进行Email消息的可靠传输  
    * 端口25
    * 传输过程：握手、消息的传输、关闭  
    * 命令/响应交互模式
        * 命令：ASCII文本
        * 响应：状态代码和语句
    * Email消息只能包含7位ASCII码  
    * 使用持久性连接  
* MIME：多媒体邮件扩展
    * 通过在邮件头部增加额外的行以声明MIME的内容格式
    ```
    Form: alice@crepes.fr
    To: bob@hamburger.edu
    Subject: Picture of yummy crepe.
    MIME-Version: 1.0
    Content-Transfer-Encoding: base64
    Content-Type: image/jpeg

    base64 encoded data …………
    ………………………………………………………………
    …………base64 encoded data
    ```
* 邮件访问协议：从服务器获取邮件
    * POP：认证/授权（客户端<-->服务器）和下载（POP3是无状态的协议）
        * 认证过程
            >客户端命令  
            > * User：声明用户名  
            > * Pass：声明密码  

            >服务器响应
            > * +OK
            > * -ERR
        * 事务阶段  
            > * List；列出消息数量
            > * Retr：用编号获取消息
            > * Dele：删除消息
            > * Quit：退出
    * IMAP：更多功能、更加复杂、能够操纵服务器上存储的消息    
        * 所有消息统一保存在一个地方：服务器
        * 允许用户利用文件夹组织消息
        * 支持跨会话的用户状态（IMAP是有状态的协议）
            > * 文件夹的名字
            > * 文件夹与消息ID之间的映射等

    * HTTP：163，QQ Mail等

## 2.5. DNS应用
* 域名解析系统：Internet上主机/路由器的识别问题
    * 多层命名服务器构成的分布式数据库
        > 为什么不使用集中式的DNS
        > * 单点失败问题
        > * 流量问题
        > * 距离问题
        > * 维护性问题
        
        > 分布式层次式
        > * Root DNS Servers `//根域名服务器`
        > * com DNS servers、org DNS servers、 edu……………… `//顶级域名服务器`
        > * yahoo.com DNS servers、pbs.org DNS servers、poly.edu……………… `//权威域名服务器`

        > 本地域名解析服务器
        > * 不严格属于层级体系
        > * 每个ISP(网络服务提供商)有一个本地域名服务器
        > * 当主机进行DNS查询时，查询被发送到本地域名服务器

    * 应用层协议：完成名字的解析
    * Internet核心功能
* DNS服务
    * 域名向IP地址的翻译
    * 主机别名
    * 邮件服务器别名
    * 均衡负载
* DNS查询
    * 迭代查询：被查询服务器返回域名解析服务器的名字，本地域名解析服务器迭代查询每级域名服务器，之后将结果给主机。本地域名服务器发送域名请求消息多次
    * 递归查询：将域名解析的任务交给所联系的服务器，被联系主机又联系下一个域名服务器，查询后原路返回给主机本地域名服务器发送域名请求消息一次
* DNS记录缓存和更新
    * 只要域名解析服务器获得域名——IP映射，即缓存这一映射
        > * 一段时间后，缓存条目失效（删除）
        > * 本地域名服务器一般会缓存顶级域名服务器的映射（因此根域名服务器不经常被访问）
    * 记录的更新/通知机制
* DNS记录和消息格式
    * 资源记录格式：（name,value,type,ttl）  `//ttl指有效时间`
    * 类型
        > * Type=A  
            > Name：主机域名  
            > Value：IP地址
        > * Type=NS  
            > Name：域（edu.cn）  
            > Value：该域权威域名解析服务器的主机域名
        > * Type=CNAME  
            > Name：某一真实域名的别名  
            > Value：真实域名
        > * Type=MX  
            > Value是与name相对应的邮件服务器
* DNS协议与消息
    * 查询和回复
    * 消息格式相同
* 占用53号端口，同时支持TCP和UDP协议

## 2.6. P2P应用
* 搜索信息
    * P2P系统的索引：信息到节点位置（IP地址+端口号）的映射
        > 集中式索引：   
        > 节点加入时，通知中央服务器：IP地址、内容

        > 洪泛式查询：  
        > * 完全分布式架构  
        > * 每个节点对它共享的文件进行索引，且只对它共享的文件进行索引  
        > * 覆盖网络：  
            > 节点和节点间如果有TCP连接，那么构成一条边(边是虚拟链路；节点一般邻居少于10个)   
            > 所有的活动节点和边构成覆盖网络  
            >```
            >* 查询消息通过已有的TCP连接发送消息  
            >* 节点转发查询消息  
            >* 如果查询命中，则利用反向路径发回查询节点   
            >```   

        >层次式覆盖网络：  
        > * 介于集中式索引和洪泛式查询之间的方法
        > * 每个节点或者是一个超级节点，或者被分配一个超级节点  
            > 节点和超级节点间维持TCP连接  
            > 某些超级节点对之间维持TCP连接    
* 文件分发：如BitTorrent

## 2.7. Socket编程
* 应用编程接口（API）：就是应用进程的控制权和操作系统的控制权进行转换的一个系统调用接口
* 标识通信端口（对外）：IP地址+端口号  
* 操作系统/进程管理套接字（对内）：套接字描述符
* 当应用程序创建套接字时，操作系统分配一个数据结构存储套接字相关信息，返回套接字描述符
### 2.7.1. 套接字API中定义的地址结构
```c
    struct sockaddr_in
    {
        u_char sin_len;//地址长度
        u_char sin_family;//地址族（TCP/IP：AF_INET）
        u_short sin_port;//端口号
        struct in_addr sin_addr;//IP地址
        char sin_zero[8];//未用（置0）
    }
```
使用TCP/IP协议簇的网络应用程序声明端点地址变量时，使用结构`sockaddr_in`
### 2.7.2. Socket API函数
* 以WinSock为例：
* **`WSAStartup`**：初始化Windows Sockets API  
    ```c
    int WSAStartup(WORD wVersionRequested,LPWSADATA IpWSAData)
    ```  
    * 使用Socket的应用程序在使用Socket之前必须首先调用`WSAStartup`函数
    * 第一个参数指明程序请求使用的WinSock版本，其中高位字节指明副版本、低位字节指明主版本。十六进制整数
        > 如0x102表示2.1版
    * 第二个参数返回实际的WinSock的版本信息，一个指向WSADATA结构的指针
    ```c
    wVersionRequested=MAKEWORD(2,1);
    err=WSAStartup(wVersionRequested,&wsaData);
    ```
* **`WSACleanup`**：释放所使用的Windows Sockets DLL
    ```c
    int WSACleanup (void);
    ```
    * 应用程序在完成对请求的Socket库的使用，最后要调用`WSACleanup`函数
    * 解除与Socket库的绑定，释放Socket库所占用的系统资源
* **`socket`**：创建套接字
    ```c
    sd=socket(protofamily,type,proto);
    ```
    * 操作系统返回套接字描述符（sd）
    * 第一个参数（协议族）： `protofamily=PF_INET` (TCP/IP)
    * 第二个参数（套接字类型）：`type=SOCK_STREAM,SOCK_DGRAM or SOCK_RAM` (TCP/IP)   
    `//SOCK_STREAM是流式套接字（面向TCP）；SOCK_DGRAM是数据报套接字（面向UDP）；SOCK_RAM是原始套接字（直接面向网络层）`
    * 第三个参数（协议号）：0为默认
    ```c
    struct protoent *p;
    p=getprotobyname("tcp");
    SOCKET sd=socket(PE_INET,SOCK_STREAM,p->p_proto);
    ```
* **`Closesocket`**
    ```c
    int closesocket(SOCKET sd);
    ```
    * 关闭一个描述符为sd的套接字
    * 在Windpws中是`closesocket()`，在Unix中是`close()`
    * 如果多个进程共享一个套接字，调用closesocket将套接字引用计数减1，减至0才关闭
    * 一个进程中的多线程对一个套接字的使用无计数（即该进程中一个线程调用closesocket将一个套接字关闭，该进程中的其他线程也将不能访问该套接字）
    * 返回值：  
    0：成功；  
    SOCKET-ERROR：失败
* **`bind`**：绑定套接字的本地端点地址
    ```c
    int bind(sd,localaddr,addrlen);
    ```
    * 参数：
        > 套接字描述符（sd）  
        > 端点地址（localaddr），结构是`sockaddr-in`
    * 客户端程序一般不必调用`bind`函数
    * 当服务器同时连接多个网络时，绑定端口地址不设一个具体的值，设为地址通配符：`INADDR_ANY`
* **`listen`**：置服务器端的流套接字处于监听状态
    ```c
    int listen(sd,queuesize);
    ```
    * 仅服务器端调用
    * 仅用于面向连接的流套接字
    * 设置连接请求队列大小（queuesize）
    * 返回值：  
    0：成功；  
    SOCKET-ERROR：失败
* **`connect`**
    ```c
    connect(sd,saddr,saddrlen);
    ```
    * 客户程序调用，使客户套接字（sd）与特定计算机的特定端口（saddr）的套接字（服务）进行连接
    * 仅用于客户端
    * 可用于TCP客户端（建立TCP连接）也可用于UDP客户端（指定服务器端点地址）
* **`accept`**
    ```c
    newsock=accept(sd,caddr,caddrlen);
    ```
    * 服务程序调用accept函数从处于监听状态的流套接字sd的客户连接请求队列中取出排在最前的一个客户请求，并且创建一个新的套接字来与客户套接字创建连接通道
    * 仅用于TCP套接字
    * 仅用于服务器
    * 利用新创建的套接字（newsock）与客户通信
* **`send`**：发送数据
    ```c
    send(sd,*buf,len,flags);
    ```
    * 用于TCP套接字（客户与服务器）或调用了`connect`函数的UDP客户端套接字
* **`sendto`**：发送数据报
    ```c
    sendto(sd,*buf,len,flags,destaddr,addrlen);
    ```
    * 用于UDP服务器端套接字与未调用`connect`函数的UDP客户端套接字
* **`recv`**：接收数据
    ```c
    recv(sd,*buffer,len,flags);
    ```
    * 从TCP连接的另一端接收数据，或者从调用了`connect`函数的UDP客户端套接字接收服务器发来的数据
* **`recvfrom`**：接收数据报
    ```c
    recvfrom(sd,*buf,len,flags,senderaddr,saddrlen);
    ```
    * 用于从UDP服务器端套接字与未调用`connect`函数的UDP客户端套接字接收对端数据
* **`setsockopt`**
    ```c
    int setsockopt(int sd,int level,int optname,*optval,int optlen);
    ```
    * 用来设置套接字sd的选项参数
* **`getsockopt`**
    ```c
    int setsockopt(int sd,int level,int optname,*optval,socklen_t *optlen);
    ```
    * 用于获取任意类型、任意状态套接口的选项当前值，并把结果存入optval
* **网络字节顺序与本地字节顺序的转换**  
    * `htons`：本地字节顺序->网络字节顺序（16bit）  
    * `ntohs`：网络字节顺序->本地字节顺序（16bit）  
    * `htonl`：本地字节顺序->网络字节顺序（32bit）  
    * `ntohl`：网络字节顺序->本地字节顺序（32bit） 
* **Socket API 调用基本流程** （WinSock、TCP）  
![Socket API 调用基本流程](SocketAPI调用基本流程.jpg)  
* **解析服务器地址**
    * 客户端可能使用域名或IP地址标识服务器，而IP协议需要使用32位二进制IP地址，需要将域名或IP地址转换为32位IP地址
    * 函数`inet_addr()`实现点分十进制IP地址到32位IP地址转换
    * 函数`gethostbyname()`实现域名到32位IP地址转换
* **解析服务器（熟知）端口号**
    * `getservbyname()`：将服务名（如HTTP）转换为熟知端口号
* **解析协议号**
    * `getprotobyname()`:将协议名（如：TCP）转换为协议号（如：6）

# 3.传输层
传输层协议为运行在不同主机上的**进程**提供了一种逻辑通信机制
## 3.1. 多路复用/分用 
### 3.1.1. 分用
* 接收端进行多路分用：传输层依据头部信息将收到的报文段（Segment）交给正确的Socket，即进程  
* 主机接受数据报（datagram):
    > 数据报包括：  
    > * 每个数据报携带源IP地址、目的IP地址  
    > * 每个数据报携带一个传输层的段（Segment）  
    > * 每个段携带源端口号和目的端口号  

    主机收到Segment之后，传输层协议提取IP地址和端口号信息，将Segment导向相应的Socket
* 无连接分用
    > UDP的Socket用二元组（目的IP地址、目的端口号）标识
    * 利用端口号创建Socket
    * 主机接收UDP段后：检查段中的目的端口号，将UDP段导向绑定在该端口号的Socket
    * 来自不同源IP地址和/或源端口号的IP数据包被导向同一个Socket
* 面向连接的分用
    > TCP的Socket用四元组（源IP地址、源端口号，目的IP地址、目的端口号）标识
    * 接收端利用所有的四个值将Segment导向合适的Socket
    * 服务器可能同时支持多个TCP Socket
    * Web服务器为每个客户端开不同的Socket
### 3.1.2. 复用
* 发送端进行多路复用：从多个Socket接收数据，为每块数据封装上头部信息，生成报文段，交给网络层
## 3.2. UDP协议
* User Datagram Protocal（RFC 768）-用户数据报协议
* 基于IP协议：提供复用/分用，简单的错误校验（UDP校验和）
* “Best effort”服务-尽力而为，可能丢失、非按序到达
* 无连接：UDP发送方与接收方不需要握手，每个UDP段的处理独立于其他段
* 优势：
    > 无需建立连接（减少延迟）  
    > 实现简单：无需建立连接状态  
    > 头部开销小  
    > 没有拥塞控制：应用可更好的控制发送时间与速率  
* 用途：常用于流媒体应用-容忍丢失、速率敏感
* 如何实现可靠传输：在应用层增加可靠性机制、应用特定的错误恢复机制
* UDP校验和（checksum）：检测UDP段在传输中是否发生错误（如位翻转）
    * 发送方
    > * 将段的内容视为16-bit整数  
    > * 校验和计算：计算所有整数的和，进位加在和的后面，将得到的值按位求反，得到校验和（*如有进位，相当于再把进位单独视为一个数，与和相加*）  
    > * 发送发将校验和放入校验和字段  
    * 接受方
    > * 计算所收到段的校验和  
    > * 将其与校验和字段进行比较  
        > 不相等：检测出错误
        > 相等：没有检测出错误（但可能有错误）
## 3.3. 可靠数据传输
 



















